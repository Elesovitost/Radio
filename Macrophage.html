<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Makrofág</title>
    <style>
        /* --- ZÁKLADNÍ STYLY --- */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Zabráníme posuvníkům prohlížeče */
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* --- HERNÍ PLÁTNO --- */
        #gameCanvas {
            display: block;
            background-color: #f0f0f0; /* Světlé pozadí pro lepší kontrast */
            position: absolute;
            top: 0;
            left: 0;
        }

        /* --- UI ELEMENTY --- */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            flex-direction: column;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10;
        }

        .ui-overlay h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 3px 3px 5px #000;
        }

        .ui-overlay p {
            font-size: 1.5em;
            margin-bottom: 30px;
        }

        .ui-overlay button {
            padding: 15px 30px;
            font-size: 1.5em;
            border: 2px solid white;
            background-color: transparent;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ui-overlay button:hover {
            background-color: white;
            color: black;
        }

        #hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.2em;
            text-align: center;
            z-index: 5;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div>Celková Hmotnost: <span id="massDisplay">0</span></div>
        <div>Počet buněk: <span id="cellCountDisplay">1</span></div>
    </div>
	<div id="leaderboard" style="
	  position: absolute;
	  top: 20px;
	  right: 20px;
	  color: white;
	  background-color: rgba(0, 0, 0, 0.5);
	  padding: 10px 15px;
	  border-radius: 10px;
	  font-family: Arial, sans-serif;
	  font-size: 16px;
	  z-index: 5;">
	</div>
    
    <div id="startScreen" class="ui-overlay">
        <h1>Makrofág</h1>
        <p>Pohybuj myší. Mezerníkem se rozděl. Cíl: sněz všechno!</p>
        <button id="startButton">Spustit Hru</button>
    </div>

	<div id="gameOverScreen" class="ui-overlay hidden">
		<h1>Konec Hry</h1>
		<p>Tvá konečná hmotnost byla: <span id="finalMass">0</span></p>
		<p id="maxMassElement"></p> <!-- <<< DOPLNIT TADY -->
		<button id="restartButton">Hrát Znovu</button>
	</div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

		const eatSmallSound = new Audio('Macrophage-eat-small.mp3');
		const eatBigSound = new Audio('Macrophage-eat-big.mp3');
		const splitSound = new Audio('Macrophage-split.mp3');
		const fuseSound = new Audio('Macrophage-fuse.mp3');


        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const massDisplay = document.getElementById('massDisplay');
        const finalMassDisplay = document.getElementById('finalMass');
        const cellCountDisplay = document.getElementById('cellCountDisplay');
        const hud = document.getElementById('hud');
		const leaderboard = document.getElementById('leaderboard');


        // --- HERNÍ KONSTANTY A NASTAVENÍ (VAŠE HODNOTY) ---
        const WORLD_SCALE_FACTOR = 3; 
        const INITIAL_PLAYER_MASS = 50; // VAŠE HODNOTA
        const FOOD_COUNT = 300;
        const AI_COUNT = 25;
		const RADIUS_SCALE_FACTOR = 5; // VAŠE HODNOTA
        const MIN_MASS_TO_SPLIT = 40;
        const MIN_MASS_TO_EAT = 1.2;
        const MASS_LOSS_PER_FRAME = 0.00000; // VAŠE HODNOTA - KORF ÚBYTKU MASY standard 0.00005
		let bacteriaFoodMultiplier = 1;  // cheat
        
        // --- KONSTANTY PRO NOVOU MECHANIKU DĚLENÍ ---
        const MERGE_TOTAL_TIME = 15; // Celkový čas do možnosti sloučení (10s + 5s)
		const MERGE_PULL_START_TIME = 5; // Čas (od konce), kdy se buňky začnou přitahovat
		
		// --- AMÉBA ---
		const SHAPE_FREQUENCY   = 7;    // počet vln kolem kruhu
		const SHAPE_AMPLITUDE   = 0.1; 

        // --- HERNÍ STAVOVÉ PROMĚNNÉ ---
        let world = { width: 0, height: 0 };
		let lastKnownPlayerCenter = null;
        let playerCells = [];
        let aiCells = [];
        let food = [];
        let mouse = { x: 0, y: 0 };
        let animationFrameId;
        let isGameOver = false;
		let maxPlayerMass = 0;
		let isPaused = false; 
		
		// klávesy
		let keys = {
			ArrowUp: false,
			ArrowDown: false,
			ArrowLeft: false,
			ArrowRight: false
		};
		let arrowControlActive = false;

		// zvuky
		function playSound(sound) {
			const s = sound.cloneNode();
			s.play();
		}

		// tyčinky na bakteriích
		function drawRadialSticks(context, x, y, radius, mass, options = {}) {
			const numSticks = Math.max(1, Math.floor(Math.sqrt(mass)));
			const stickLength = options.stickLength || radius * 0.2;
			const stickColor = options.stickColor || '#000';
			const stickWidth = options.stickWidth || 2;

			for (let i = 0; i < numSticks; i++) {
				const angle = (i / numSticks) * 2 * Math.PI;
				const startX = x + Math.cos(angle) * radius;
				const startY = y + Math.sin(angle) * radius;
				const endX = x + Math.cos(angle) * (radius + stickLength);
				const endY = y + Math.sin(angle) * (radius + stickLength);

				context.beginPath();
				context.strokeStyle = stickColor;
				context.lineWidth = stickWidth;
				context.moveTo(startX, startY);
				context.lineTo(endX, endY);
				context.stroke();
			}
		}


        class Cell {
            constructor(x, y, mass, color) {
                this.x = x;
                this.y = y;
                this.mass = mass;
				this.displayMass = mass;   
                this.color = color || this.getRandomColor();
                this.updateRadius();
                
                this.targetX = x;
                this.targetY = y;
            }

			updateRadius(mass = this.displayMass) {
				this.radius = RADIUS_SCALE_FACTOR * Math.sqrt(mass / Math.PI);
			}

			animateMass(deltaTime) {
				if (this.displayMass !== this.mass) {
					const diff = this.mass - this.displayMass;
					// interpolace s časovým krokem 0.2 s
					const step = diff * Math.min(1, deltaTime / 0.2);
					this.displayMass += step;
					this.updateRadius();
				}
			}
            // VAŠE METODA RYCHLOSTI
            getSpeed() {
                return 4 / Math.pow(this.radius, 0.2);
            }

            // VAŠE METODA POHYBU S INTEGROVANOU LOGIKOU VYSTŘELENÍ
			move() {
				if (this.splitVelocity && (this.splitVelocity.x !== 0 || this.splitVelocity.y !== 0)) {
					this.x += this.splitVelocity.x;
					this.y += this.splitVelocity.y;
					this.splitVelocity.x *= 0.92;
					this.splitVelocity.y *= 0.92;
					if (Math.abs(this.splitVelocity.x) < 0.1) this.splitVelocity.x = 0;
					if (Math.abs(this.splitVelocity.y) < 0.1) this.splitVelocity.y = 0;
				}

				const speed = this.getSpeed();
				const dx = this.targetX - this.x;
				const dy = this.targetY - this.y;
				const dist = Math.sqrt(dx * dx + dy * dy);

				// Nová logika: zpomalení podle vzdálenosti od středu
				const maxSlowDist = 100; // vzdálenost, kde už se nebrzdí
				const minSpeedFactor = 0.2; // nikdy se úplně nezastaví

				// faktor rychlosti: čím blíž středu, tím menší
				let factor = dist / maxSlowDist;
				factor = Math.min(Math.max(factor, minSpeedFactor), 1);

				this.x += (dx / dist) * speed * factor;
				this.y += (dy / dist) * speed * factor;

				this.x = Math.max(this.radius, Math.min(world.width - this.radius, this.x));
				this.y = Math.max(this.radius, Math.min(world.height - this.radius, this.y));
			}


            loseMass() {
                if (this.mass > INITIAL_PLAYER_MASS) {
                    this.mass *= (1 - MASS_LOSS_PER_FRAME);
                    this.updateRadius();
                }
            }

            draw(context) {
                context.beginPath();
                context.fillStyle = this.color;
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fill();
                context.strokeStyle = this.getStrokeColor();
                context.lineWidth = Math.max(2, this.radius * 0.05);
                context.stroke();
                context.closePath();
            }

            getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
            
            getStrokeColor() {
                let color = this.color;
                if (color.startsWith('#')) color = color.substring(1);
                let r = parseInt(color.substring(0, 2), 16);
                let g = parseInt(color.substring(2, 4), 16);
                let b = parseInt(color.substring(4, 6), 16);
                r = Math.max(0, r - 40).toString(16).padStart(2, '0');
                g = Math.max(0, g - 40).toString(16).padStart(2, '0');
                b = Math.max(0, b - 40).toString(16).padStart(2, '0');
                return `#${r}${g}${b}`;
            }
        }
		
			class PlayerCell extends Cell {
				constructor(x, y, mass) {
					super(x, y, mass, '#3498db');
					this.mergeTimer = 0; 
					this.splitVelocity = { x: 0, y: 0 };
					this.vx = 0;   // okamžitá rychlost po ose X
					this.vy = 0;   // okamžitá rychlost po ose Y

				}

				updateTarget(mouseX, mouseY) {
					this.targetX = mouseX;
					this.targetY = mouseY;
				}

				updateMergeTimer() {
					if (this.mergeTimer > 0) {
						this.mergeTimer -= 1 / 60;
					}
				}

				setMergeDelay() {
					this.mergeTimer = MERGE_TOTAL_TIME;
				}

				draw(context) {
					// spočítáme čas pro animaci výběžků
					const time = performance.now() * 0.002;
					const steps = 20; // počet segmentů tvaru
					const points = [];

					// vygenerujeme body kolem kruhu s vlnkami
					for (let i = 0; i < steps; i++) {
						const angle = (i / steps) * Math.PI * 2;
						const noise = Math.sin(angle * SHAPE_FREQUENCY + time);
						const r = this.radius * (1 + noise * SHAPE_AMPLITUDE);
						points.push({
							x: this.x + r * Math.cos(angle),
							y: this.y + r * Math.sin(angle)
						});
					}

					// vykreslíme nepravidelný útvar
					context.beginPath();
					context.fillStyle = this.color;
					context.moveTo(points[0].x, points[0].y);
					points.forEach(p => context.lineTo(p.x, p.y));
					context.closePath();
					context.fill();

					// obrys
					context.strokeStyle = this.getStrokeColor();
					context.lineWidth = Math.max(2, this.radius * 0.05);
					context.stroke();

					// číslo uprostřed
					context.fillStyle = '#fff';
					context.font = `${Math.max(10, this.radius * 0.1 + 10)}px Arial`;
					context.textAlign = 'center';
					context.textBaseline = 'middle';
					context.fillText(Math.round(this.mass), this.x, this.y);
				}

			}



        class AiCell extends Cell {
            constructor(x, y, mass, groupID = null) {
                super(x, y, mass);
				this.groupID = groupID || Math.random().toString(36).substr(2, 9);
                this.aiState = 'wandering';
                this.decisionTimer = 0;
				this.mergeTimer = 0;
            }
			
			
			draw(context) {
				// Kruh buňky
				context.beginPath();
				context.fillStyle = this.color;
				context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
				context.fill();

				// Tyčinky:
				drawRadialSticks(context, this.x, this.y, this.radius, this.mass, {
					stickColor: '#000',
					stickLength: this.radius * 0.2,
					stickWidth: 2
				});

				// Obvod
				context.beginPath();
				context.strokeStyle = this.getStrokeColor();
				context.lineWidth = Math.max(2, this.radius * 0.05);
				context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
				context.stroke();
			}

			

			updateAI(allCells, food) {
			  // 1) Merge-timer ubíhá, aby se buňky mohly později sloučit
			  if (this.mergeTimer > 0) {
				this.mergeTimer -= 1/60;
			  }

			  // 2) Identifikace leadera v rámci skupiny
			  const group  = this.getGroupCells();
			  const leader = group.reduce((a, b) => a.mass > b.mass ? a : b);

			  // 3) Follower: vždy target na leadera a pohyb
			  if (this !== leader && this.decisionTimer <= 0) {
				this.targetX = leader.x;
				this.targetY = leader.y;
				this.move();
				this.loseMass();
				return;
			  }

			  // 4) Leader: klasické rozhodování
			  this.decisionTimer -= 1/60;
			  if (this.decisionTimer <= 0) {
				this.makeDecision(allCells, food);
				this.decisionTimer = Math.random() * 2 + 1;
			  }
			  this.move();
			  this.loseMass();
			}

			
            isTargetReached() {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                return Math.sqrt(dx*dx + dy*dy) < this.radius;
            }
            findNewWanderTarget() {
                let closestFood = null;
                let minDistance = Infinity;
                for (const f of food) {
                    const dx = f.x - this.x;
                    const dy = f.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestFood = f;
                    }
                }
                if (closestFood) {
                    this.targetX = closestFood.x;
                    this.targetY = closestFood.y;
                } else {
                    this.targetX = Math.random() * world.width;
                    this.targetY = Math.random() * world.height;
                }
            }
			makeDecision(allCells, food) {
				const group = this.getGroupCells();
				const leader = group.reduce((a, b) => a.mass > b.mass ? a : b);

				if (this !== leader) {
					// Podřízené buňky sledují vůdce
					this.aiState = leader.aiState;
					this.targetX = leader.targetX;
					this.targetY = leader.targetY;
					return;
				}

				// Vůdce rozhoduje za celou skupinu
				const potentialThreats = [];
				const potentialPrey = [];

				// Zjisti všechny ostatní buňky
				const allOtherCells = allCells.filter(c => {
					if (c === this) return false; // Ignoruj sebe
					if (c.groupID && c.groupID === this.groupID) return false; // Ignoruj buňky ze své skupiny
					return true;
				});

				for (const other of allOtherCells) {
					const dx = other.x - this.x;
					const dy = other.y - this.y;
					const dist = Math.hypot(dx, dy);

					// Hrozby (větší buňky) v dosahu 400px
					if (other.mass > this.mass * MIN_MASS_TO_EAT && dist < other.radius + this.radius + 400) {
						potentialThreats.push({ cell: other, dist: dist, dx: dx, dy: dy });
					} 
					// Kořist (menší buňky) v dosahu 400px
					else if (this.mass > other.mass * MIN_MASS_TO_EAT && dist < this.radius + 400) {
						potentialPrey.push({ cell: other, dist: dist });
					}
				}

				// === NOVÁ, VYLEPŠENÁ LOGIKA ÚTĚKU ===
				if (potentialThreats.length > 0) {
					this.aiState = 'fleeing';
					
					// 1. Vypočítej kombinovaný vektor útěku od VŠECH hrozeb
					let totalFleeX = 0;
					let totalFleeY = 0;
					potentialThreats.forEach(threat => {
						const fleeVecX = this.x - threat.cell.x;
						const fleeVecY = this.y - threat.cell.y;
						const weight = 1 / (threat.dist * threat.dist);
						totalFleeX += fleeVecX * weight;
						totalFleeY += fleeVecY * weight;
					});

					const fleeMagnitude = Math.hypot(totalFleeX, totalFleeY);
					if (fleeMagnitude === 0) { // Vzácný případ, kdy se síly vyruší
						 this.aiState = 'wandering';
						 this.findNewWanderTarget();
						 return;
					}

					let fleeDirX = totalFleeX / fleeMagnitude;
					let fleeDirY = totalFleeY / fleeMagnitude;
					
					const margin = this.radius + 15;

					// 2. Zkontroluj past v rohu a případně proveď "MiseryEscape"
					const isTop = this.y < margin;
					const isBottom = this.y > world.height - margin;
					const isLeft = this.x < margin;
					const isRight = this.x > world.width - margin;
					
					const trappedInCorner = (isTop && isLeft) || (isTop && isRight) || (isBottom && isLeft) || (isBottom && isRight);

					if (trappedInCorner && this.mass >= MIN_MASS_TO_SPLIT) {
						this.performMiseryEscape();
						return; // Rozhodnutí bylo provedeno
					}

					// 3. Chování u okraje: držet se zdi, nebo se odlepit?
					if (isTop || isBottom || isLeft || isRight) {
						potentialThreats.sort((a, b) => a.dist - b.dist);
						const closestThreat = potentialThreats[0];
						// Bezpečná vzdálenost pro opuštění zdi
						const safeLeaveDistance = closestThreat.cell.radius + this.radius + 200;

						// Pokud je nejbližší hrozba dostatečně daleko, snaž se odlepit od zdi
						if (closestThreat.dist > safeLeaveDistance) {
							let wallNormalX = 0, wallNormalY = 0;
							if(isLeft) wallNormalX = 1; else if(isRight) wallNormalX = -1;
							if(isTop) wallNormalY = 1; else if(isBottom) wallNormalY = -1;
							
							const peelFactor = 0.4; // Jak silně se má AI "odlepit"
							fleeDirX = fleeDirX * (1 - peelFactor) + wallNormalX * peelFactor;
							fleeDirY = fleeDirY * (1 - peelFactor) + wallNormalY * peelFactor;

						} else {
							// Není bezpečno: drž se zdi, pokud do ní směřuješ
							if (isLeft && fleeDirX < 0) fleeDirX = 0;
							if (isRight && fleeDirX > 0) fleeDirX = 0;
							if (isTop && fleeDirY < 0) fleeDirY = 0;
							if (isBottom && fleeDirY > 0) fleeDirY = 0;
						}

						// Přepočítání a normalizace finálního vektoru směru
						const finalMagnitude = Math.hypot(fleeDirX, fleeDirY);
						if (finalMagnitude > 0.01) {
							fleeDirX /= finalMagnitude;
							fleeDirY /= finalMagnitude;
						}
					}
					
					// 4. Nastav finální cíl útěku
					const fleeDistance = 600;
					this.targetX = this.x + fleeDirX * fleeDistance;
					this.targetY = this.y + fleeDirY * fleeDistance;
					
					return;
				}

				// === PŮVODNÍ LOGIKA LOVU A TOULÁNÍ (beze změny) ===
				if (potentialPrey.length > 0) {
					// Seřadíme potenciální kořist podle vzdálenosti
					potentialPrey.sort((a, b) => a.dist - b.dist);
					const closestPrey = potentialPrey[0].cell;
					const dist = potentialPrey[0].dist;
					const maxPreyMass = potentialPrey.reduce((max, p) => Math.max(max, p.cell.mass), 0);
					const nearbyPreyCount = potentialPrey.filter(p => p.dist < 300).length;

					this.aiState = 'hunting';
					this.targetX = closestPrey.x;
					this.targetY = closestPrey.y;

					// --- Standardní split: pokud je v dosahu (300 px) a kořist má méně než polovinu hmotnosti ---
					if (
						this.mergeTimer <= 0 &&
						this.mass >= MIN_MASS_TO_SPLIT &&
						closestPrey.mass * 2.2 < this.mass &&
						dist < 300
					) {
						this.performHuntingSplit(closestPrey);
						return;  // Ukončíme rozhodování po splitu
					}

					// --- Vylepšený split pro více kořisti (stávající implementace) ---
					if (
						this.mergeTimer <= 0 &&
						this.mass >= MIN_MASS_TO_SPLIT &&
						this.mass > maxPreyMass * 2.2 &&
						nearbyPreyCount >= 2 &&
						dist < 300
					) {
						this.performHuntingSplit(closestPrey);
					}
					return;
				}


				this.aiState = 'wandering';
				this.findNewWanderTarget();
			}

			getGroupCells() {
				return aiCells.filter(c => c.groupID === this.groupID);
			}
			

			performHuntingSplit(target) {
			  // 1) Poloviční hmotnost a aktualizace poloměru
			  this.mass /= 2;
			  this.updateRadius();

			  // 2) Inicializace merge-timer (blokace zpětného sloučení)
			  this.mergeTimer = MERGE_TOTAL_TIME;

			  // 3) Vypočítáme úhel směrem ke kořisti
			  const angle = Math.atan2(target.y - this.y, target.x - this.x);

			  // 4) Vytvoříme dceřinou buňku se split-velocity
			  const newCell = new AiCell(this.x, this.y, this.mass, this.groupID);
			  newCell.color = this.color;
			  newCell.mergeTimer = MERGE_TOTAL_TIME;
			  const launchSpeed = 20;
			  newCell.splitVelocity = {
				x: Math.cos(angle) * launchSpeed,
				y: Math.sin(angle) * launchSpeed
			  };

			  // 5) Dceřiná buňka ihned targetuje střed rodiče
				newCell.targetX = newCell.x + Math.cos(angle) * 400;
				newCell.targetY = newCell.y + Math.sin(angle) * 400;
				newCell.decisionTimer = 0.5;

			  // 6) Rodič ihned dělá nové rozhodnutí
			  this.decisionTimer = 0;
			  this.makeDecision([...playerCells, ...aiCells], food);

			  // 7) Přidání dcery do pole AI buněk
			  aiCells.push(newCell);
			}
			
			performMiseryEscape() {
				if (this.mass < MIN_MASS_TO_SPLIT) return;

				//playSound(splitSound); // Volitelný zvuk pro útěk
				this.mass /= 2;
				this.updateRadius();

				const newMass = this.mass;
				const newCell = new AiCell(this.x, this.y, newMass, this.groupID);
				newCell.color = this.color;
				
				// Obě buňky dostanou časovač, aby se hned nespojily
				this.mergeTimer = MERGE_TOTAL_TIME;
				newCell.mergeTimer = MERGE_TOTAL_TIME;
				
				// Určí směr úniku - diagonálně pryč z rohu
				let escapeDirX = this.x < world.width / 2 ? 1 : -1;
				let escapeDirY = this.y < world.height / 2 ? 1 : -1;
				
				// Normalizace vektoru (aby měl délku 1)
				const mag = Math.hypot(escapeDirX, escapeDirY);
				escapeDirX /= mag;
				escapeDirY /= mag;

				const launchSpeed = 25; // Vyšší rychlost pro zoufalý únik
				newCell.splitVelocity = {
					x: escapeDirX * launchSpeed,
					y: escapeDirY * launchSpeed
				};

				newCell.targetX      = newCell.x + escapeDirX * 400;
				newCell.targetY      = newCell.y + escapeDirY * 400;
				newCell.decisionTimer = MERGE_TOTAL_TIME;
				this.decisionTimer    = MERGE_TOTAL_TIME;

				aiCells.push(newCell);

				// Původní buňka se také lehce odsune od rohu
				this.splitVelocity = {
					x: escapeDirX * -5,
					y: escapeDirY * -5
				};
				
				this.decisionTimer = 3; // Dej AI čas na útěk, než se znovu rozhodne
				aiCells.push(newCell);
			}


        }

		// VAŠE TŘÍDA PRO JÍDLO
		class Food {
			constructor(x, y) {
				this.x = x;
				this.y = y;
				this.mass = Math.floor(Math.random() * 5) + 1;
				this.radius = 3 + this.mass * 2;
				const colors = ['#f1c40f', '#e74c3c', '#2ecc71', '#9b59b6', '#1abc9c'];
				this.color = colors[Math.floor(Math.random() * colors.length)];
			}
			draw(context) {
				context.beginPath();
				context.fillStyle = this.color;
				context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
				context.fill();
				context.closePath();
				context.fillStyle = '#000';
				context.font = `${this.radius}px Arial`;
				context.textAlign = 'center';
				context.textBaseline = 'middle';
				context.fillText(this.mass, this.x, this.y);
			}
		}

			function init() {
				isGameOver = false;
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
				world.width = canvas.width * WORLD_SCALE_FACTOR;
				world.height = canvas.height * WORLD_SCALE_FACTOR;
				playerCells = [new PlayerCell(world.width / 2, world.height / 2, INITIAL_PLAYER_MASS)];
				aiCells = [];
				for (let i = 0; i < AI_COUNT; i++) {
					const mass = Math.random() * 80 + 30;   // VELIKOST
					aiCells.push(new AiCell(Math.random() * world.width, Math.random() * world.height, mass));
				}
				food = [];
				for (let i = 0; i < FOOD_COUNT; i++) {
					food.push(new Food(Math.random() * world.width, Math.random() * world.height));
				}
				hud.classList.add('hidden'); // skryj HUD při pauze
				gameOverScreen.classList.add('hidden');
				if (animationFrameId) cancelAnimationFrame(animationFrameId);
				draw(); // hned vykresli pauznutou scénu
			}


			function gameLoop() {
				if (isGameOver) return;

				if (startScreen.classList.contains('hidden') && !isPaused) {
					update(); // jen když není pauza
				}
				draw(); // kreslíme vždy
				animationFrameId = requestAnimationFrame(gameLoop);
			}

		
        function update() {
			const playerCenter = getPlayerCenter();
			const camX = -playerCenter.x + canvas.width / 2;
			const camY = -playerCenter.y + canvas.height / 2;
			const clampedCamX = Math.max(Math.min(camX, 0), canvas.width - world.width);
			const clampedCamY = Math.max(Math.min(camY, 0), canvas.height - world.height);
			const worldMouseX = mouse.x - clampedCamX;
			const worldMouseY = mouse.y - clampedCamY;

			playerCells.forEach(playerCell => {
				if (arrowControlActive) {
					if (keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight) {
						// 1) nastavíme novou rychlost
						const speed = playerCell.getSpeed();
						let dx = 0, dy = 0;
						if (keys.ArrowUp)    dy -= 1;
						if (keys.ArrowDown)  dy += 1;
						if (keys.ArrowLeft)  dx -= 1;
						if (keys.ArrowRight) dx += 1;
						const len = Math.hypot(dx, dy);
						if (len > 0) {
							dx /= len; dy /= len;
							playerCell.vx = dx * speed;
							playerCell.vy = dy * speed;
						}
					} else {
						// 2) zpomalení při uvolnění šipek během 2 s (≈120 snímků)
						const friction = 1 - (1 / 60);
						playerCell.vx *= friction;
						playerCell.vy *= friction;
					}
					// 3) aplikace rychlosti na pozici a ořez do hran světa
					playerCell.x = Math.max(playerCell.radius,
						Math.min(world.width  - playerCell.radius, playerCell.x + playerCell.vx));
					playerCell.y = Math.max(playerCell.radius,
						Math.min(world.height - playerCell.radius, playerCell.y + playerCell.vy));
				} else {
					// standardní pohyb podle myši
					playerCell.updateTarget(worldMouseX, worldMouseY);
					playerCell.move();
				}
				playerCell.loseMass();
				playerCell.updateMergeTimer();
			});


            
            applyMergeForce();
			applyAIMergeForce();
            handlePlayerMerging();
			handleAIMerging();
            const allCells = [...playerCells, ...aiCells];
            aiCells.forEach(ai => ai.updateAI(allCells, food));
            handleCollisions();
			
			playerCells.forEach(cell => cell.animateMass(1/60));
			aiCells.forEach(cell => cell.animateMass(1/60));
            
			  // === CHEAT ZDE ===
			applyCheat_BoostBacteriaMass();
			
            if (playerCells.length === 0 && !isGameOver) {
                endGame();
            }

			const playerMass = playerCells.reduce((sum, c) => sum + c.mass, 0);

			// Spočítat všechny skupiny AI podle groupID
			const aiGroupMasses = new Map();
			for (const ai of aiCells) {
				const prev = aiGroupMasses.get(ai.groupID) || 0;
				aiGroupMasses.set(ai.groupID, prev + ai.mass);
			}

			// Získat všechny skupiny včetně hráče
			const allGroupMasses = [playerMass, ...aiGroupMasses.values()];

			// Najít největší skupinu
			const maxGroupMass = Math.max(...allGroupMasses);

			// Podmínka: mám aspoň 10 000 a jsem největší ze všech
			if (playerMass >= 10000 && playerMass === maxGroupMass && !isGameOver) {
				showBestMacrophageScreen();
			}

			
            updateHUD();
			

        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            const playerCenter = getPlayerCenter();
            const camX = -playerCenter.x + canvas.width / 2;
            const camY = -playerCenter.y + canvas.height / 2;
            const clampedCamX = Math.max(Math.min(camX, 0), canvas.width - world.width);
            const clampedCamY = Math.max(Math.min(camY, 0), canvas.height - world.height);
            ctx.translate(clampedCamX, clampedCamY);
            drawGrid();
            food.forEach(f => f.draw(ctx));
            const allCells = [...playerCells, ...aiCells].sort((a, b) => a.mass - b.mass);
            allCells.forEach(cell => cell.draw(ctx));
            ctx.restore();
			
			    // <<< TADY: když pauza, napiš text
			if (isPaused) {
				ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				ctx.fillStyle = "white";
				ctx.font = "bold 60px Arial";
				ctx.textAlign = "center";
				ctx.fillText("PAUZA (P)", canvas.width / 2, canvas.height / 2);
			}
			
        }

        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x <= world.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, world.height);
                ctx.stroke();
            }
            for (let y = 0; y <= world.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(world.width, y);
                ctx.stroke();
            }
        }
        
		function handleCollisions() {
			const allMovingCells = [...playerCells, ...aiCells];

			// Jídlo
			for (let i = food.length - 1; i >= 0; i--) {
				const f = food[i];
				for (const cell of allMovingCells) {
					const dx = cell.x - f.x;
					const dy = cell.y - f.y;
					const dist = Math.sqrt(dx * dx + dy * dy);
					if (dist < cell.radius) {
						      if (aiCells.includes(cell)) {
								cell.mass += f.mass * bacteriaFoodMultiplier;
							  } else {
								cell.mass += f.mass;
							  }
						cell.updateRadius();
						food.splice(i, 1);
						food.push(new Food(Math.random() * world.width, Math.random() * world.height));

							if (playerCells.includes(cell)) {
								playSound(eatSmallSound);
							}

						break;
					}
				}
			}

			// Požírání mezi buňkami — ALE ne mezi vlastními hráčskými!
			for (let i = allMovingCells.length - 1; i >= 0; i--) {
				for (let j = allMovingCells.length - 1; j >= 0; j--) {
					if (i === j) continue;
					const cell1 = allMovingCells[i];
					const cell2 = allMovingCells[j];
					if (!cell1 || !cell2) continue;

					// OMEZ: pokud jsou obě hráčské buňky, přeskoč
					if (playerCells.includes(cell1) && playerCells.includes(cell2)) continue;

					const dx = cell1.x - cell2.x;
					const dy = cell1.y - cell2.y;
					const dist = Math.sqrt(dx * dx + dy * dy);
					const bigger = cell1.mass > cell2.mass ? cell1 : cell2;
					const smaller = cell1.mass > cell2.mass ? cell2 : cell1;

					if (dist < bigger.radius - smaller.radius * 0.2) {
						if (bigger.mass > smaller.mass * MIN_MASS_TO_EAT) {
							bigger.mass += smaller.mass;
							bigger.updateRadius();
							
							        // Pokud bigger je hráč a smaller je AI:
								if (playerCells.includes(bigger) && aiCells.includes(smaller)) {
									playSound(eatBigSound);
								}
							
							removeCell(smaller);
							allMovingCells.splice(j, 1);
							if (j < i) i--;
						}
					}
				}
			}
		}

        
			function removeCell(cellToRemove) {
				let index = playerCells.indexOf(cellToRemove);
				if (index > -1) {
					playerCells.splice(index, 1);
					return;
				}
				index = aiCells.indexOf(cellToRemove);
				if (index > -1) {
					aiCells.splice(index, 1);
					// Přidá novou AI jen pokud celkový počet AI je menší než AI_COUNT
					if (aiCells.length < AI_COUNT) {
						const mass = Math.random() * 80 + 30;
						aiCells.push(new AiCell(Math.random() * world.width, Math.random() * world.height, mass));
					}
				}
			}

			// --- NOVÉ applyMergeForce: během mergeTimer>0 jen separace (žádný pull) ---
			function applyMergeForce() {
			  for (let i = 0; i < playerCells.length; i++) {
				for (let j = i + 1; j < playerCells.length; j++) {
				  const cell1 = playerCells[i];
				  const cell2 = playerCells[j];

				  // pokud je jedna z buněk ve fázi mergeTimer > 0, zabráníme překrytí
				  if (cell1.mergeTimer > 0 || cell2.mergeTimer > 0) {
					const dx   = cell2.x - cell1.x;
					const dy   = cell2.y - cell1.y;
					const dist = Math.hypot(dx, dy);
					const minDist = cell1.radius + cell2.radius;

					if (dist > 0 && dist < minDist) {
					  const overlap = (minDist - dist) / 2;
					  const ox = (dx / dist) * overlap;
					  const oy = (dy / dist) * overlap;

					  cell1.x -= ox;
					  cell1.y -= oy;
					  cell2.x += ox;
					  cell2.y += oy;
					}
				  }
				}
			  }
			}

			// --- NOVÉ applyAIMergeForce: během mergeTimer>0 jen separace (žádný pull) ---
			function applyAIMergeForce() {
			  for (let i = 0; i < aiCells.length; i++) {
				for (let j = i + 1; j < aiCells.length; j++) {
				  const cell1 = aiCells[i];
				  const cell2 = aiCells[j];
				  if (cell1.groupID !== cell2.groupID) continue;

				  // pokud je jedna z buněk ve fázi mergeTimer > 0, zabráníme překrytí
				  if (cell1.mergeTimer > 0 || cell2.mergeTimer > 0) {
					const dx   = cell2.x - cell1.x;
					const dy   = cell2.y - cell1.y;
					const dist = Math.hypot(dx, dy);
					const minDist = cell1.radius + cell2.radius;

					if (dist > 0 && dist < minDist) {
					  const overlap = (minDist - dist) / 2;
					  const ox = (dx / dist) * overlap;
					  const oy = (dy / dist) * overlap;

					  cell1.x -= ox;
					  cell1.y -= oy;
					  cell2.x += ox;
					  cell2.y += oy;
					}
				  }
				}
			  }
			}



			function handlePlayerMerging() {
				if (playerCells.length <= 1) return;
				for (let i = 0; i < playerCells.length; i++) {
					for (let j = i + 1; j < playerCells.length; j++) {
						const cell1 = playerCells[i];
						const cell2 = playerCells[j];
						// merge jen pokud už mohou:
						if (cell1.mergeTimer <= 0 && cell2.mergeTimer <= 0) {
							const dx = cell1.x - cell2.x;
							const dy = cell1.y - cell2.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							const bigger = cell1.mass > cell2.mass ? cell1 : cell2;
							const smaller = cell1.mass > cell2.mass ? cell2 : cell1;

							if (dist < bigger.radius * 0.2) {
								bigger.mass += smaller.mass;
								bigger.updateRadius();
								bigger.mergeTimer = 0;
								bigger.splitVelocity.x = 0;
								bigger.splitVelocity.y = 0;
								playerCells.splice(playerCells.indexOf(smaller), 1);
								j--;
								playSound(fuseSound);
							}
						}
					}
				}
			}

			function handleAIMerging() {
				if (aiCells.length <= 1) return;
				for (let i = 0; i < aiCells.length; i++) {
					for (let j = i + 1; j < aiCells.length; j++) {
						const cell1 = aiCells[i];
						const cell2 = aiCells[j];
						if (cell1.groupID !== cell2.groupID) continue; // jen stejné AI

						if (cell1.mergeTimer <= 0 && cell2.mergeTimer <= 0) {
							const dx = cell1.x - cell2.x;
							const dy = cell1.y - cell2.y;
							const dist = Math.sqrt(dx * dx + dy * dy);
							const bigger = cell1.mass > cell2.mass ? cell1 : cell2;
							const smaller = cell1.mass > cell2.mass ? cell2 : cell1;

							if (dist < bigger.radius * 0.2) {
								bigger.mass += smaller.mass;
								bigger.updateRadius();
								aiCells.splice(aiCells.indexOf(smaller), 1);
								j--;
								playSound(fuseSound);
							}
						}
					}
				}
			}


        
			function splitPlayer() {
				const playerCenter = getPlayerCenter();
				const camX = -playerCenter.x + canvas.width / 2;
				const camY = -playerCenter.y + canvas.height / 2;
				const clampedCamX = Math.max(Math.min(camX, 0), canvas.width - world.width);
				const clampedCamY = Math.max(Math.min(camY, 0), canvas.height - world.height);

				const worldMouseX = mouse.x - clampedCamX;
				const worldMouseY = mouse.y - clampedCamY;

				const cellsToSplit = [...playerCells];
				for (const cell of cellsToSplit) {
					if (cell.mass >= MIN_MASS_TO_SPLIT) {
						cell.mass /= 2;
						cell.updateRadius();
						const newMass = cell.mass;
						const angle = Math.atan2(worldMouseY - cell.y, worldMouseX - cell.x);
						const newCell = new PlayerCell(cell.x, cell.y, newMass);
						const launchSpeed = 20;
						newCell.splitVelocity.x = Math.cos(angle) * launchSpeed;
						newCell.splitVelocity.y = Math.sin(angle) * launchSpeed;
						cell.setMergeDelay();
						newCell.setMergeDelay();
						playerCells.push(newCell);
					}
				}
				playSound(splitSound);
			}


		function getPlayerCenter() {
		  if (playerCells.length === 0) {
			return lastKnownPlayerCenter || { x: world.width / 2, y: world.height / 2 };
		  }
		  let totalX = 0, totalY = 0, totalMass = 0;
		  playerCells.forEach(cell => {
			totalX += cell.x * cell.mass;
			totalY += cell.y * cell.mass;
			totalMass += cell.mass;
		  });
		  const center = { x: totalX / totalMass, y: totalY / totalMass };
		  lastKnownPlayerCenter = center; // uložíme pro případ budoucí prázdnoty
		  return center;
		}

        
		function updateHUD() {
		  const totalMass = playerCells.reduce((sum, cell) => sum + cell.mass, 0);
		  massDisplay.textContent = Math.round(totalMass);
		  cellCountDisplay.textContent = playerCells.length;

		  if (totalMass > maxPlayerMass) {
			maxPlayerMass = totalMass;
		  }

		  // === NOVÝ LEADERBOARD ===
		  const leaderboardMap = new Map();

		  // 1) Hráč: všechny jeho buňky jako jeden záznam
		  leaderboardMap.set('Player', playerCells.reduce((sum, c) => sum + c.mass, 0));

		  // 2) AI: seskupit podle groupID
		  for (const ai of aiCells) {
			const id = ai.groupID;
			const prev = leaderboardMap.get(id) || 0;
			leaderboardMap.set(id, prev + ai.mass);
		  }

		  // 3) Převést na pole a seřadit
		  const allGroups = [];
		  for (const [key, mass] of leaderboardMap) {
			const label = key === 'Player' ? 'Hráč' : 'AI';
			allGroups.push({ label, mass });
		  }

		  allGroups.sort((a, b) => b.mass - a.mass);

		  // 4) Top 10
		  const top10 = allGroups.slice(0, 10);

		  // 5) Vykreslit
		  let html = `<strong>Top 10:</strong><br>`;
		  top10.forEach((entry, idx) => {
			html += `${idx + 1}. ${entry.label}: ${Math.round(entry.mass)}<br>`;
		  });

		  leaderboard.innerHTML = html;
		}



		function applyCheat_BoostBacteriaMass() {
		  if (playerCells.length === 0) {
			bacteriaFoodMultiplier = 1;
			return;
		  }

		  const playerMass = playerCells.reduce((sum, c) => sum + c.mass, 0);
		  const aiMasses = aiCells.map(c => c.mass);
		  if (aiMasses.length === 0) {
			bacteriaFoodMultiplier = 1;
			return;
		  }

		  const maxAiMass = Math.max(...aiMasses);
		  const secondMaxMass = aiMasses.filter(m => m !== maxAiMass)
										 .reduce((max, m) => Math.max(max, m), 0);

		  if (playerMass > maxAiMass) {
			bacteriaFoodMultiplier = 2;
			if (playerMass > secondMaxMass * 1.2) {
			  bacteriaFoodMultiplier = 5;
			}
		  } else {
			bacteriaFoodMultiplier = 1;
		  }
		}

		let gameOverTimeoutId = null;
		function endGame() {
		  if (gameOverTimeoutId !== null) return; // ZABRÁNÍ opakovanému volání!

		  lastKnownPlayerCenter = getPlayerCenter();

		  const totalMass = playerCells.reduce((sum, cell) => sum + cell.mass, 0);
		  finalMassDisplay.textContent = Math.round(totalMass);
		  const maxMassElement = document.getElementById('maxMassElement');
		  maxMassElement.textContent = `Maximální dosažená hmotnost: ${Math.round(maxPlayerMass)}`;

		  hud.classList.add('hidden');

		  gameOverTimeoutId = setTimeout(() => {
			isGameOver = true; // Tím vypneš update + loop
			cancelAnimationFrame(animationFrameId); // pro jistotu
			gameOverScreen.classList.remove('hidden');
			gameOverTimeoutId = null; // reset, aby šlo opakovat
		  }, 2000);
		}




		function showBestMacrophageScreen() {
			isGameOver = true;
			cancelAnimationFrame(animationFrameId);
			const totalMass = playerCells.reduce((sum, cell) => sum + cell.mass, 0);
			finalMassDisplay.textContent = Math.round(totalMass);

			const maxMassElement = document.getElementById('maxMassElement');
			maxMassElement.innerHTML = `<span style="
				font-size: 3em;
				font-weight: bold;
				background: linear-gradient(90deg, red, orange, yellow, green, cyan, blue, violet);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
				display: inline-block;
			">NEJLEPŠÍ MAKROFÁG</span>`;

			hud.classList.add('hidden');
			gameOverScreen.classList.remove('hidden');
		}


			window.addEventListener('mousemove', e => {
				arrowControlActive = false;          // obnoví ovládání myší
				mouse.x = e.clientX;
				mouse.y = e.clientY;
			});

		
		window.addEventListener('mousedown', e => {
			if (e.button === 0 && playerCells.length > 0 && !isGameOver && !isPaused && startScreen.classList.contains('hidden')) {
				splitPlayer();
			}
		});
		
        window.addEventListener('resize', () => {
            if (!startScreen.classList.contains('hidden')) init();
        });
		
		window.addEventListener('keydown', e => {
			if (e.code in keys) {
				keys[e.code] = true;        // klávesu držíme
				arrowControlActive = true;  // přepni do režimu šipky
			}
			if (e.code === 'Space' && playerCells.length > 0 && !isGameOver) {
				e.preventDefault();
				splitPlayer();
			}
			if (e.code === 'KeyP' && !isGameOver && startScreen.classList.contains('hidden')) {
				isPaused = !isPaused;
			}
			if (e.code === 'KeyB' && !isGameOver && startScreen.classList.contains('hidden')) {
    // Cheat: přidá hráči +1000 mass rovnoměrně
    const extra = 1000 / playerCells.length;
    playerCells.forEach(cell => {
        cell.mass += extra;
        cell.updateRadius();
    });
}
		});


		window.addEventListener('keyup', e => {
			if (e.code in keys) {
				keys[e.code] = false;      // klávesu uvolněnou nastavíme na false
				// režim arrowControlActive zůstává aktivní až do prvního pohybu myší
			}
		});


		startButton.addEventListener('click', () => {
			startScreen.classList.add('hidden');
			hud.classList.remove('hidden');
			gameOverScreen.classList.add('hidden');
			isGameOver = false; // důležité!
		});

		restartButton.addEventListener('click', () => {
		  if (animationFrameId) cancelAnimationFrame(animationFrameId); // <-- TADY ZASTAV!
		  isGameOver = false;
		  gameOverScreen.classList.add('hidden');
		  startScreen.classList.add('hidden');
		  hud.classList.remove('hidden');
		  init();
		  gameLoop(); // spustí NOVÝ loop
		});



		init();
		gameLoop();
    });
	
	

	
    </script>
</body>
</html>